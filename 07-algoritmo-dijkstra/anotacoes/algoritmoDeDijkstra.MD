### Problema

No estudo inicial de grafos e pesquisa em largura, estudamos o problema do caminho m√≠nimo onde analisamos o menor caminho poss√≠vel at√© um determinado v√©rtice objetivo, mas n√£o tinhamos mais nenhum por√©m, bastava descobrirmos o menor caminho por n√∫mero de v√©rtice e tudo estava resolvido, mas e se o caminho com menor n√∫mero de v√©rtices tiver um custo maior que o caminho com um pouco mais de v√©rtices ?

Imagine que o caminho com menor n√∫mero de v√©rtices tenha um custo de tempo maior por arestas. Se estivermos de carro e tivermos um caminho para o nosso destino que em tese √© menor, mas est√° com tr√¢nsito absurdo, em contra-partida o nosso caminho mais distante do objetivo est√° com o caminho livre, pode ser que o tempo para chegar no nosso objetivo seja menor usando o maior caminho. Chamamos isso de peso da aresta e o grafo com esses pesos √© dito grafo ponderado, as vezes o peso elevado nas arestas do menor caminho faz com que outro caminho maior seja a melhor decis√£o, mas nosso algoritmo de pesquisa em largura n√£o consegue lidar com isso. E agora ?

---

### Algoritmo de Dijkstra

Utilizaremos o algoritmo de Dijkstra para ir do v√©rtice inicial para o v√©rtice objetivo no menor tempo poss√≠vel.

Esse algoritmo consiste de 4 etapas:

1) A partir do v√©rtice de origem encontre o pr√≥ximo v√©rtice onde o custo de sua aresta seja o menor.

2) A partir desse v√©rtice que tem a aresta de menor custo, recalcule o custo para os vizinhos dele.

3) Repita isso para os pr√≥ximos v√©rtice at√© que atinja o v√©rtice objetivo.

4) Calcule o caminho final.

---

### Execu√ß√£o do algoritmo

#### Grafo

```mermaid
graph LR
    inicio((inicio)) -->|6| A((A))
    inicio -->|2| B((B))
    B -->|3| A
    A -->|1| fim((fim))
    B -->|5| fim
```

#### Etapa 1 ‚Äì an√°lise inicial

Devemos criar uma tabela com todos os v√©rtices dispon√≠veis em nosso grafo e associar seu custo e seu pai, caso n√£o tenha sido analisado aquele v√©rtice ainda deve ser marcado o custo como infinito e o pai indefinido.

Voc√™ est√° no ponto inicial e analisa os vizinhos `A` e `B`.  
- Custo at√© `A`: **6**  
- Custo at√© `B`: **2**

Tabela inicial:

| **V√âRTICE** | **CUSTO** | **PAI** |
|:-----------:|:---------:|:-------:|
| A | 6 | inicio |
| B | 2 | inicio |
| fim | ‚àû | indefinido |

---

#### Etapa 2 ‚Äì vizinhos de B

O v√©rtice com **menor custo** √© `B (2)`.  
Recalculando custos a partir dele:

| **V√âRTICE** | **CUSTO** | **PAI** |
|:-----------:|:---------:|:-------:|
| A | ~~6~~ ‚Üí **5** | ~~inicio~~ ‚Üí **B** |
| B | 2 | inicio |
| fim | **7** | **B** |

---

#### Etapa 3 ‚Äì vizinhos de A

Agora o menor custo √© `A (5)`.  
Recalculando a partir de `A`:

| **V√âRTICE** | **CUSTO** | **PAI** |
|:-----------:|:---------:|:-------:|
| A | 5 | B |
| B | 2 | inicio |
| fim | ~~7~~ ‚Üí **6** | ~~B~~ ‚Üí **A** |

---

#### Caminho final

Quando o pr√≥ximo v√©rtice com menor custo a ser analisado √© o v√©rtice final a execu√ß√£o do algoritmo acaba.

Caminho reconstru√≠do a partir dos pais:

```
inicio ‚Üí B ‚Üí A ‚Üí fim
```

Custo total: **6**

> üí° **Observa√ß√£o:**  
> A *pesquisa em largura (BFS)* encontraria o caminho com menos arestas, mas n√£o o mais econ√¥mico em custo total.  
> O Dijkstra, ao considerar os pesos, encontra o caminho √≥timo de custo 6.

---

### Ciclo em grafos

Quando adicionamos ciclos a um grafo direcionado, isso serve apenas para nos gerar mais custo, independente da formata√ß√£o do grafo, o custo de ir at√© um v√©rtice A, voltar para o v√©rtice B e voltar para o v√©rtice A novamente foi uma opera√ß√£o que adicionou uma complexidade a mais.

No cap√≠tulo anterior vimos a quest√£o de grafos direcionados e grafos n√£o direcionados, os direcionados s√≥ ter√£o ciclos de forma explicita, pois cada a aresta desse grafo n√£o ser√° m√£o dupla, ent√£o ter√£o que ter 2 arestas com setas para indicar o ciclo de um v√©rtice a outro, j√° o grafo n√£o direcionado faz com que cada v√©rtice seja m√£o dupla, virando assim um ciclo. Todo grafo n√£o direciona tem ciclos.

O algoritmo de Dijkstra s√≥ funciona em grafos sem ciclos ou em grafos de ciclo positivo. 

### Arestas negativas

Imagina que no exemplo anterior para ir de B at√© A o custo fosse de -3, isso faria com que o custo para sair de inicio at√© A passando por B fosse: 2 - 3 = -1, ou seja seria ainda melhor esse caminho, por√©m arestas com pesos negativos estragam o algoritmo de Dijkstra. Para esses casos a melhor alternativa que √© o algoritmo de Bellman-ford que n√£o ser√° abordado no livro de estudo.
